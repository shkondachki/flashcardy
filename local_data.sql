--
-- PostgreSQL database dump
--

\restrict KTTQNQdZ7TAGnYMTQBJ3dkljGT0M11ptmkK0ZByaYA60ovQO5aWfOuwZYW8aLLy

-- Dumped from database version 18.1
-- Dumped by pg_dump version 18.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: _prisma_migrations; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public._prisma_migrations (id, checksum, finished_at, migration_name, logs, rolled_back_at, started_at, applied_steps_count) FROM stdin;
a6f0781f-58c3-4360-8502-78df7e94c3a9	4df34c5895c493c912c80336364befb6593e5a3681d4921bcd67a88888a04959	2025-12-28 17:11:19.637786+02	20251219200919_flashcardy	\N	\N	2025-12-28 17:11:19.625913+02	1
5f2c61fc-7a9d-4921-97b0-8cb1feb9b35d	7bb85449c9e28c5304dcc1ae76d1b8c1e2309b44ac212450a0dc9899738a5273	2025-12-28 17:11:22.30601+02	20251228151122_add_user_model	\N	\N	2025-12-28 17:11:22.293924+02	1
\.


--
-- Data for Name: flashcards; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.flashcards (id, question, answer, tech, categories, difficulty, "createdAt", "updatedAt") FROM stdin;
a66cf5de-c63d-493e-9d2d-d4ea281dcbcd	Combining String Literal Types (Template Literal Types)	**What it is**\n\nTypeScript lets you **build new string unions** by combining other string unions using **backticks (`)**.\n\n**Why it exists**\n\nTo **strictly control string formats** (CSS classes, event names, API routes).\n\n**How it works**\n\n```tsx\ntypeSize ="sm" |"md";\ntypeColor ="red" |"blue";\n\ntypeButtonClass =`${Size}-${Color}`;\n// "sm-red" | "sm-blue" | "md-red" | "md-blue"\n```\n\n**Interview line**\n\n> Template literal types let you generate precise string unions by combining other string literal types.\n>	TypeScript	{ts}	easy	2025-12-28 16:27:51.591	2025-12-29 18:06:22.562
7a9845aa-1530-44cb-8a54-d046a2318864	var, let, const	- **var**: function-scoped, hoisted with `undefined`, reassignable\n- **let**: block-scoped, hoisted but TDZ (Temporal Dead Zone), reassignable\n- **const**: block-scoped, hoisted but TDZ, not reassignable (binding immutable, objects still mutable)	JavaScript	{}	easy	2025-12-29 21:17:19.171	2025-12-29 21:17:19.171
370d7c84-f3ba-4873-8437-2a9f8a6bd128	Closures	- Function that **remembers variables from outer scope** even after outer function finishes.\n- Useful for **private variables, memoization, and function factories**.\n- Example:\n\n```jsx\nfunction counter() {\n  let count = 0;\n  return () => ++count;\n}\nconst c = counter();\nc(); // 1\nc(); // 2\n```	JavaScript	{}	easy	2025-12-29 21:17:43.328	2025-12-29 21:17:43.328
f504a58d-af01-4a94-be78-1761165dc44e	Equality	- `==`: loose equality, **type coercion**\n- `===`: strict equality, no type coercion\n\nExample:\n\n```jsx\nnull == undefined  // true\nnull === undefined // false\n```	JavaScript	{}	easy	2025-12-29 21:18:40.733	2025-12-29 21:18:40.733
bf6ea19d-a071-47d7-b494-443c5f19034e	Event Loop	- JS is single-threaded; event loop handles async code.\n- **Call stack ΓåÆ microtasks (Promises) ΓåÆ macrotasks (setTimeout, setInterval)**\n\nExample:\n\n```jsx\nconsole.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('End');\n// Output: Start, End, Promise, Timeout\n```	JavaScript	{}	easy	2025-12-29 21:18:51.903	2025-12-29 21:18:51.903
f287c4c3-98e0-4f90-8740-cfdf12441091	Hoisting	- JS moves **declarations** to top of scope before execution.\n- `var` ΓåÆ hoisted + initialized to undefined\n- `let`/`const` ΓåÆ hoisted but uninitialized (TDZ)	JavaScript	{}	easy	2025-12-29 21:19:20.697	2025-12-29 21:19:20.697
05a7e77a-bef9-4ec9-9a95-a16dbb13d335	this keyword	- Refers to **execution context**:\n    1. **Global function** ΓåÆ window/global object (or undefined in strict mode)\n    2. **Object method** ΓåÆ object\n    3. **Explicit binding** ΓåÆ `.call`, `.apply`, `.bind`\n    4. **Constructor / class** ΓåÆ newly created object\n- **Arrow functions**: inherit `this` from lexical scope	JavaScript	{}	easy	2025-12-29 21:19:38.233	2025-12-29 21:19:38.233
20eb33b7-ea8c-4fd2-977d-623f0e54a341	setTimeout + var / let / closures	- `var` in loop ΓåÆ same variable for all iterations, often causes same value logged\n- **Fix:**\n    1. Use `let` (block-scoped)\n    2. Use **closure/IIFE** to capture value\n\nExample (closure):\n\n```jsx\nfor (var i=0; i<3; i++) {\n  setTimeout((j => () => console.log(j))(i), i*100);\n}\n// Logs: 0,1,2\n```	JavaScript	{}	easy	2025-12-29 21:20:33.563	2025-12-29 21:31:04.736
2030be6c-061b-4d1b-9ac4-938f5aaf35db	null / undefined quirks	- `typeof null` ΓåÆ `"object"` (legacy quirk)\n- `typeof undefined` ΓåÆ `"undefined"`\n- `null == undefined` ΓåÆ true\n- `null === undefined` ΓåÆ false	JavaScript	{}	easy	2025-12-29 21:20:46.22	2025-12-29 21:31:10.066
74ac0288-476a-4a06-8861-0e5a393939db	Best Practices / Interview Tips JS	- Prefer `===` over `==`\n- Always explain **why**, not just output\n- Mention **closures and block-scoping** for loop + async questions\n- Understand **event loop, call stack, microtasks/macrotasks**\n- Arrow functions inherit `this` ΓåÆ useful for React event handlers\n- Keep examples short, clear, and concise	JavaScript	{}	easy	2025-12-29 21:21:22.95	2025-12-29 21:31:14.963
2f2cf366-6b34-4c2d-99f5-f76ebe127707	What is a TypeScript Generic?	**What it is**\n\nA way to write **reusable, type-safe code** that works with **any type**, without losing type information.\n\n**Why not `any`?**\n\n`any` removes safety. Generics **preserve the exact type**.\n\n**Example**\n\n```tsx\nfunction identity<T>(value: T): T {\n\treturn value;\n}\n```\n\n```tsx\nidentity<number>(5);// returns number\nidentity("hello");// T inferred as string\n```\n\n**Real-world use**\n\n- API responses\n- Repositories\n- Reusable components/hooks\n\n**Interview line**\n\n> Generics allow functions and classes to remain flexible while preserving strict type safety.\n>	TypeScript	{}	easy	2025-12-29 21:36:06.901	2025-12-29 21:36:06.901
16e9ed5a-8925-4241-a965-94a83e55afed	How .d.ts Files Work	**What they are**\n\n**Type-only files** that describe the shape of JavaScript code.\n\n**When theyΓÇÖre used**\n\n- JS libraries without TS\n- Global variables\n- Third-party SDKs\n\n**Example**\n\n```tsx\n// my-lib.d.ts\ndeclarefunctionmyLib(value:string):number;\n```\n\n**Key rule**\n\n- `.d.ts` files **do not emit JS**\n- They exist **only for the TypeScript compiler**\n\n**Interview line**\n\n> .d.ts files provide type information for JavaScript code without changing runtime behavior.\n>	TypeScript	{}	easy	2025-12-29 21:38:54.575	2025-12-29 21:38:54.575
61876e4c-1d8e-490a-9192-40f8b189c728	Writing Conditional Types	**What it is**\n\nTypes that behave like an **ifΓÇôelse** statement.\n\n**Syntax**\n\n```tsx\nT extends U ? X : Y\n```\n\n**Example**\n\n```tsx\ntype IsString<T> = T extends string ? true :false;\n\ntype A = IsString<string>;// true\ntype B = IsString<number>;// false\n```\n\n**Why itΓÇÖs powerful**\n\n- Used internally by TS utility types\n- Enables **type-level logic**\n\n**Interview line**\n\n> Conditional types allow TypeScript to choose a type dynamically based on a condition.\n>	TypeScript	{}	easy	2025-12-29 21:36:30.963	2025-12-29 21:36:30.963
3bfc76f3-c6a3-4d45-904b-b0f032e2929e	Inferring Return Types from Async Functions	**Problem**\n\nAsync functions return `Promise<T>`, but you often want **just `T`**.\n\n**Solution**\n\n```tsx\ntype Result = Awaited<ReturnType<typeof fetchUser>>;\n```\n\n**Example**\n\n```tsx\nasync function fetchUser() {\n  return { id: 1, name: "Alice" };\n}\n```\n\n```tsx\ntype User = Awaited<ReturnType<typeof fetchUser>>;\n// { id: number; name: string }\n```\n\n**Why it matters**\n\n- Keeps types in sync\n- No duplication\n- Very common in React hooks\n\n**Interview line**\n\n> ReturnType extracts the functionΓÇÖs return, and Awaited unwraps the Promise.\n>	TypeScript	{}	easy	2025-12-29 21:37:10.71	2025-12-29 21:37:10.71
f23c39a3-3d1c-46cc-b63b-ba6832b611bb	Difference Between `type` and `interface`	### Similarities\n\n- Both define object shapes\n- Both support extension\n\n### Key Differences\n\n| Feature | `interface` | `type` |\n| --- | --- | --- |\n| Declaration merging | Γ£à Yes | Γ¥î No |\n| Union types | Γ¥î No | Γ£à Yes |\n| Primitives | Γ¥î No | Γ£à Yes |\n| Preferred for APIs | Γ£à Yes | ΓÜá Depends |\n\n**Example**\n\n```tsx\ninterface User {\n  name: string;\n}\n\ntype UserType = {\n  name: string;\n} | null;\n```\n\n**Rule of thumb**\n\n- **Interfaces** ΓåÆ public APIs, objects\n- **Types** ΓåÆ unions, advanced composition\n\n**Interview line**\n\n> Interfaces are extendable and mergeable, while types are more flexible and powerful for composition.\n>	TypeScript	{}	easy	2025-12-29 21:39:39.87	2025-12-29 21:39:39.87
7b09a3a9-879f-4dea-b1b6-5c3c8e1d7670	What is a Triple-Slash Directive?	**What it is**\n\n```tsx\n/// <reference types="node" />\n```\n\n**Purpose**\n\n- Manually includes other type definitions\n\n**Status**\n\n- ΓÜá∩╕Å **Legacy**\n- Mostly replaced by:\n    - `tsconfig.json`\n    - ES imports\n\n**When you see it**\n\n- Old codebases\n- Global ambient typings\n\n**Interview line**\n\n> Triple-slash directives are an older way to reference type declarations and are rarely needed today.\n>	TypeScript	{}	easy	2025-12-29 21:55:07.849	2025-12-29 21:55:07.849
3a30a03d-acf0-47ea-a387-05ce3dbaf989	What is a TypeScript Record?	**What it is**\n\nA utility type for **object maps** with fixed key and value types.\n\n**Syntax**\n\n```tsx\nRecord<KeyType, ValueType>\n```\n\n**Example**\n\n```tsx\ntype Roles = "admin" | "user";\n\ntype Permissions = Record<Roles, boolean>;\n```\n\n```tsx\nconst perms: Permissions = {\n  admin: true,\n  user: false,\n};\n```\n\n**Why itΓÇÖs useful**\n\n- Cleaner than manual object typing\n- Enforces **all keys exist**\n\n**Interview line**\n\n> Record defines an object where every key maps to the same value type.\n>	TypeScript	{}	easy	2025-12-29 21:55:24.948	2025-12-29 21:55:24.948
23732986-f5be-4c5d-8a65-8979ef3af602	Generic Functions in TypeScript	**What it is**\n\nFunctions that use **type parameters** to stay flexible while preserving exact types.\n\n**Why it matters**\n\nAvoids `any`, keeps **full type safety**, and makes utilities reusable.\n\n**Example**\n\n```tsx\nfunction identity<T>(value: T): T {\n  return value;\n}\n```\n\n```tsx\nidentity(5);       // number\nidentity("test");  // string\n```\n\n**Senior insight**\n\nGenerics are about **capturing relationships between inputs and outputs**, not just flexibility.\n\n**Interview line**\n\n> Generics allow reusable code while preserving precise type information across function boundaries.\n>	TypeScript	{}	easy	2025-12-29 21:55:49.97	2025-12-29 21:55:49.97
4fcb560f-f691-486d-b48d-cff25a086292	What is `as const`	**What it is**\n\nA **compile-time** feature that:\n\n- Narrows values to **literal types**\n- Makes objects **deeply readonly**\n\n**Example**\n\n```tsx\nconst config = {\n  env: "prod",\n  retries: 3,\n} as const;\n```\n\n```tsx\n// config.env ΓåÆ "prod" (not string)\n// config.retries ΓåÆ 3 (not number)\n```\n\n**vs `const`**\n\n- `const` ΓåÆ variable canΓÇÖt be reassigned\n- `as const` ΓåÆ **properties canΓÇÖt be changed**\n\n**vs `Object.freeze`**\n\n| `as const` | `Object.freeze` |\n| --- | --- |\n| Compile-time | Runtime |\n| Deep readonly | Shallow freeze |\n| TS-only | JS behavior |\n\n**Interview line**\n\n> as const enforces deep immutability at compile time and preserves literal types.\n>	TypeScript	{}	easy	2025-12-29 21:56:17.781	2025-12-29 21:56:17.781
2181deb0-843b-44bf-bfa2-fada643ec3ba	`private` Access Modifier	**What it is**\n\nRestricts class members to be accessible **only inside the class**.\n\n**Example**\n\n```tsx\nclass Service {\n  private config = {};\n\n  getConfig() {\n    return this.config;\n  }\n}\n```\n\n**Why it matters**\n\n- Enforces **encapsulation**\n- Reduces accidental misuse\n- Aligns with **SOLID (Interface Segregation)**\n\n**Senior insight**\n\nYou expose **behavior**, not **implementation details**.\n\n**Interview line**\n\n> private enforces encapsulation by preventing external access to internal class details.\n>	TypeScript	{}	easy	2025-12-29 21:56:50.616	2025-12-29 21:56:50.616
20ef3709-e4da-44ca-952c-525f0f9ad3a8	Decorators in TypeScript	**What they are**\n\nFunctions that **wrap or modify classes, methods, or properties**.\n\n**Example**\n\n```tsx\n@Injectable()\nclass UserService {}\n```\n\n**Why theyΓÇÖre powerful**\n\n- Add behavior **without inheritance**\n- Encourage **composition over inheritance**\n- Avoid deep prototype chains\n\n**Where you see them**\n\n- Angular (`@Component`, `@Injectable`)\n- Next.js\n- Dependency injection systems\n\n**Important note**\n\n- Experimental feature\n- Mostly framework-driven\n\n**Interview line**\n\n> Decorators enable reusable behavior through composition rather than inheritance.\n>	TypeScript	{}	easy	2025-12-29 21:57:08.407	2025-12-29 21:57:08.407
b1009a93-4fbb-4de3-804c-1fd2d3d6f932	`type` vs `interface` differences	### Key Differences\n\n| Feature | `interface` | `type` |\n| --- | --- | --- |\n| Declaration merging | Γ£à Yes | Γ¥î No |\n| Unions / intersections | Γ¥î No | Γ£à Yes |\n| Best for | Public APIs | Domain modeling |\n\n**Example**\n\n```tsx\ninterface User {\n  name: string;\n}\n```\n\n```tsx\ntype Result = Success | Error;\n```\n\n**Senior rule of thumb**\n\n- **Interfaces** ΓåÆ extensible contracts (libraries, React props)\n- **Types** ΓåÆ complex logic (unions, intersections)\n\n**Interview line**\n\n> Interfaces are extendable and mergeable, while types excel at composition and unions.\n>	TypeScript	{}	easy	2025-12-29 21:57:33.364	2025-12-29 21:57:33.364
775bcae4-34f5-44c8-a2ca-c4e3f1c1696a	Type Guards	**What they are**\n\nFunctions (or expressions) that **narrow union types at runtime**.\n\n**Example**\n\n```tsx\ntype Fruit = Apple | Pineapple;\n\nfunction isPineapple(fruit: Fruit): fruit is Pineapple {\n  return fruit.kind === "pineapple";\n}\n```\n\n```tsx\nif (isPineapple(fruit)) {\n  fruit.crown; // safe\n}\n```\n\n**Why they matter**\n\n- Enable **safe branching logic**\n- Critical for domain modeling\n\n**Built-in guards**\n\n- `typeof`\n- `instanceof`\n- `in`\n\n**Interview line**\n\n> Type guards allow TypeScript to safely narrow union types at runtime.\n>	TypeScript	{}	easy	2025-12-29 21:57:58.789	2025-12-29 21:57:58.789
c04515bf-f7a6-49db-9070-fd8b13baaaab	Structural vs Nominal Typing	### Structural Typing (TypeScript)\n\n**Rule**\n\n> ΓÇ£If it looks like a duck, itΓÇÖs a duck.ΓÇ¥\n> \n\n**Example**\n\n```tsx\ntype User = { id: number };\n\nconst obj = { id: 1, name: "A" };\n\nconst user: User = obj; // Γ£à allowed\n```\n\n### Nominal Typing (Java, C++)\n\n- Types must share the **same declared identity**\n- Shape alone is not enough\n\n**Why TS chose structural typing**\n\n- Less boilerplate\n- Better interoperability\n- Easier refactoring\n\n**Interview line**\n\n> TypeScript uses structural typing, meaning compatibility is based on shape, not explicit identity.\n>	TypeScript	{}	easy	2025-12-29 21:58:17.864	2025-12-29 21:58:17.864
51fe5ac3-6a3b-49b4-ab60-1fe1d332565a	Compile-time vs Runtime	- TypeScript exists **only at compile time**\n- No types exist in production JS\n- All safety disappears after build\n\n**Interview line**\n\n> TypeScript improves developer safety but does not change runtime behavior.\n>	TypeScript	{}	easy	2025-12-29 22:39:47.312	2025-12-29 22:39:47.312
d402f0e5-5fe1-4615-bfb9-de5001a6c982	What is React and Its Popularity	- React is a popular JavaScript library known for building powerful user interfaces, primarily due to its component-based architecture that allows developers to create reusable UI components.\n- A key feature of React is its virtual DOM, which minimizes direct DOM manipulations, leading to significantly improved performance.\n- The video promises to delve deeper into the virtual DOM in subsequent sections.	React	{}	easy	2025-12-29 22:46:45.194	2025-12-29 22:46:45.194
bfd4ea84-40f3-4aad-8ac0-e49d5422811c	Single Page Applications (SPAs)	- A single page application (SPA) loads a single HTML page and updates only the necessary parts of the page based on user interactions, rather than reloading the entire page.\n- This approach results in faster load times, better responsiveness, and smoother user interactions.\n- However, SPAs can pose challenges for search engine optimization since they typically use a single URL, making it harder for search engines to crawl and index content effectively.	React	{}	easy	2025-12-29 22:47:11.831	2025-12-29 22:47:11.831
b4648659-371e-4ca9-999a-3355ef730f3e	JSX and Its Differences from HTML	- JSX, or JavaScript XML, is a syntax extension for JavaScript that allows developers to write HTML-like code directly within JavaScript files.\n- A critical difference between JSX and HTML is that JSX requires all self-closing tags to be properly closed, similar to XHTML, while this is not a requirement in standard HTML.	React	{}	easy	2025-12-29 22:47:23.192	2025-12-29 22:47:23.192
cccb15c5-65ab-4ae1-9212-d59237c85969	Functional vs Class Components	- Class components were the primary method for creating components in React before the introduction of hooks, often seen as complex and traditional.\n- Functional components, introduced later, are simpler and easier to use, especially after the introduction of hooks, which allow them to manage state and lifecycle events.\n- Class components manage state using 'this.state' and 'this.setState', while functional components utilize hooks like 'useState' and 'useEffect' for similar purposes.	React	{}	easy	2025-12-29 22:47:32.555	2025-12-29 22:47:40.532
ee986e09-5b08-444f-8f36-f861f2d4f849	Stateless vs Stateful Components	- Stateless components do not manage or store their own data and simply display content passed to them via props, making them ideal for static presentations.\n- Stateful components can manage their own state and update it based on user interaction or events, allowing them to handle more complex logic.\n- With the introduction of hooks, functional components can now also be either stateful or stateless, providing greater flexibility in component design.	React	{}	easy	2025-12-29 22:47:55.123	2025-12-29 22:47:55.123
cba21707-f6ab-40f7-a2c0-e33911922d86	Understanding Props in React	- Props, short for properties, are used to pass data from parent components to child components in React, and these values are read-only in child components.\n- Both props and state are essential for controlling and manipulating component behavior and rendering, but they serve different purposes in the component lifecycle.	React	{}	easy	2025-12-29 22:48:12.59	2025-12-29 22:48:12.59
af4e7d64-415e-430a-bbbf-156b0fc19889	State vs Props	- State is a mutable object that stores dynamic data which can change over time due to user interactions, network requests, or other events.\n- Props are immutable and cannot be modified by the child component; they are controlled by the parent component and provide a way to pass data down the component tree.	React	{}	easy	2025-12-29 22:48:23.205	2025-12-29 22:48:23.205
4c3184d4-ac86-4939-a8bf-06ac875fe4c5	Controlled vs Uncontrolled Components	- Controlled components are those that manage their own input data through state, making them ideal for scenarios requiring validation or dynamic updates.\n- Uncontrolled components, on the other hand, do not require React to manage their state and are typically used for simpler tasks like file uploads or subscriptions, where direct inspection of inputs is unnecessary.	React	{}	easy	2025-12-29 22:48:41.536	2025-12-29 22:48:41.536
4acb299e-b26f-4cb8-a6a7-ff770be1aa93	Key Attribute in React Lists	- The key attribute in React is essential for identifying individual items in a list, allowing React to efficiently track and update items during re-renders.\n- By using keys, React can determine which elements have changed, been added, or removed, thus optimizing the rendering process and improving performance.	React	{}	easy	2025-12-29 22:48:50.703	2025-12-29 22:48:50.703
ce12836c-a5cd-479a-937b-7f756484fa6f	Fragments in React	- Fragments in React allow developers to group multiple elements without adding an extra node to the DOM, enabling cleaner markup.\n- They are particularly useful for returning multiple elements from a component without the need for an additional wrapper element like a div.	React	{}	easy	2025-12-29 22:48:59.392	2025-12-29 22:48:59.392
f91c9a4d-22b2-4295-a152-93c68219a977	Virtual DOM and Performance	- The virtual DOM is a lightweight in-memory representation of the actual DOM, which React uses to optimize rendering performance.\n- When a component is updated, React compares the new virtual DOM with the previous version and only updates the parts of the actual DOM that have changed, thus improving efficiency.	React	{}	easy	2025-12-29 22:49:12.169	2025-12-29 22:49:12.169
8f9896d0-6204-4971-b2d9-057bf50b648a	React Lifecycle Methods	- React lifecycle methods allow developers to hook into specific points in a component's lifecycle, including mounting, updating, and unmounting phases.\n- These methods enable developers to perform actions at critical moments, such as initializing state, fetching data, or cleaning up resources before a component is removed.	React	{}	easy	2025-12-29 22:49:23.023	2025-12-29 22:49:23.023
f5cef97a-f865-4098-b96a-74fb8372320d	useState and useEffect Hooks	- The useState hook is used to manage state in functional components, allowing for the creation of state variables that can be updated and rendered dynamically.\n- The useEffect hook is used to perform side effects, such as data fetching or subscriptions, and runs after every render, allowing developers to manage component behavior effectively.	React	{}	easy	2025-12-29 22:49:33.738	2025-12-29 22:49:33.738
18d65706-9a16-4bc5-9e44-4f2bb1f43a35	Props Drilling	- Props drilling refers to the process of passing data through multiple layers of components, which can become cumbersome if many intermediary components are involved.\n- This can lead to complications in managing data flow and understanding where props originate, especially in deeply nested component hierarchies.	React	{}	easy	2025-12-29 22:54:14.888	2025-12-29 22:54:14.888
864f058d-6f5b-4519-bb21-ace7056b8b91	Context API for State Management	- The Context API provides a solution to props drilling by allowing developers to create global variables that can be accessed directly by any component in the tree without the need for manual prop passing.\n- This feature simplifies state management and enhances code readability by reducing the complexity associated with deeply nested component structures.	React	{}	easy	2025-12-29 22:54:23.773	2025-12-29 22:54:23.773
53686011-0319-4318-80f3-643ef0cb9200	Higher Order Components	- Higher order components (HOCs) are functions that take a component as input and return a new component with added functionality or modified behavior.\n- HOCs are useful for applying common functionality, such as authentication or data fetching, across multiple components without rewriting code.	React	{}	easy	2025-12-29 22:54:35.34	2025-12-29 22:54:35.34
33cc1e64-2807-41b6-b9d1-6365b8be201e	Reconciliation in React	- Reconciliation is the process React uses to update the DOM efficiently by comparing the virtual DOM with the actual DOM and only applying necessary changes.\n- This process involves creating a new virtual DOM, diffing it against the previous version, and updating the actual DOM accordingly, which optimizes performance during component updates.	React	{}	easy	2025-12-29 22:54:45.3	2025-12-29 22:54:45.3
3362b13f-bb40-4032-8da5-f06cee65f2f8	React Portals	- React portals allow developers to render a component's children into a different part of the DOM outside the parent component's hierarchy while maintaining the React component structure.\n- This is particularly useful for creating modals or tooltips that need to overlay other content without being constrained by the parent component's layout.	React	{}	easy	2025-12-29 22:54:55.011	2025-12-29 22:54:55.011
5add89f9-740c-4ef2-93ab-c630adc62003	React Router for Navigation	- React Router is a library that enables navigation between different pages in a single-page application without reloading the entire page, allowing for a seamless user experience.\n- It facilitates the creation of routes and links, making it easy to manage navigation within the application while keeping the user interface responsive and fluid.	React	{}	easy	2025-12-29 22:55:07.752	2025-12-29 22:55:07.752
7c30b1cf-84f5-4149-a7f1-8099da8ab800	React Strict Mode	- React Strict Mode is a development tool that helps identify potential issues in an application by intentionally invoking warnings and behaviors that promote best practices.\n- It acts as a safety net for developers, ensuring that code adheres to safe coding practices and that any warnings are addressed early to prevent errors in production.	React	{}	easy	2025-12-29 22:55:16.015	2025-12-29 22:55:16.015
feff9b84-62f6-43b2-9fe4-58f0a97aa405	What is microtask starvation?	Microtask starvation occurs when:\n\n- Microtasks continuously schedule more microtasks\n- Task queue never gets a chance to run\n\nResult:\n\n- UI freezes\n- `setTimeout` callbacks are delayed indefinitely	JavaScript	{}	easy	2026-01-01 22:34:25.863	2026-01-01 22:34:25.863
47087b01-522e-4c18-9ec3-fbb3f3a1ec0b	What is the JavaScript Call Stack and why is it fundamental to JS execution?	The call stack is a LIFO (Last In, First Out) structure that tracks execution contexts.\n\nWhy itΓÇÖs fundamental:\n- Ensures synchronous execution\n- Tracks where execution should return\n- Enables nested calls\n- Detects runtime errors like stack overflow\n\nJavaScript is single-threaded, so only one stack frame executes at a time.	JavaScript	{"call stack"}	easy	2026-01-01 22:09:17.759	2026-01-01 22:10:31.525
4226a564-e567-43d8-877e-56393cf70484	What is an execution context and how does it relate to the call stack?	An execution context is the environment where JS code runs.\n\nEach context contains:\n- Variable Environment\n- Lexical Environment\n- `this` binding\n\nTypes:\n- Global Execution Context\n- Function Execution Context\n\nEach execution context is pushed onto the call stack when a function is called and popped when it finishes.	JavaScript	{"call stack"}	easy	2026-01-01 22:20:35.001	2026-01-01 22:20:45.937
8f5c7b77-79cd-4d60-a60f-0165dd72f57c	What causes ΓÇ£Maximum call stack size exceededΓÇ¥ and how do you prevent it?	Causes:\n- Infinite recursion\n- Deep recursion without a base case\n- Circular function calls\n\nPrevention:\n- Always define a **base case**\n- Convert recursion to **iteration**\n- Use tail recursion (limited support)	JavaScript	{"call stack"}	easy	2026-01-01 22:22:21.165	2026-01-01 22:22:44.787
2c6cafb8-e868-4045-aca5-cf7a05f8d4fd	Is the JavaScript call stack synchronous or asynchronous?	The call stack is **strictly synchronous**.\n\n- Executes **one function at a time**\n- Blocking code blocks everything\n- Async behavior comes from **Web APIs + Event Loop**, not the stack itself	JavaScript	{}	easy	2026-01-01 22:26:15.051	2026-01-01 22:26:15.051
4c3e5715-edb7-4da7-b606-bb770230d5c3	What is the Event Loop and what problem does it solve?	The **Event Loop** coordinates:\n\n- Call Stack\n- Web APIs\n- Task Queue\n- Microtask Queue\n\nIt allows JavaScript to be **non-blocking** by:\n\n- Waiting for the call stack to be empty\n- Then pushing queued callbacks to the stack	JavaScript	{"event loop"}	easy	2026-01-01 22:26:46.489	2026-01-01 22:26:46.489
9271aeb8-0ef0-472b-8d60-71b1cd7e1fae	What is the difference between the Task Queue and the Microtask Queue?	**Microtask Queue (higher priority):**\n\n- `Promise.then`\n- `catch`\n- `finally`\n- `queueMicrotask`\n\n**Task Queue (lower priority):**\n\n- `setTimeout`\n- `setInterval`\n- DOM events\n\nExecution order:\n\n1. Call stack\n2. Microtasks (ALL of them)\n3. One task from Task Queue	JavaScript	{"task queue"}	easy	2026-01-01 22:27:51.819	2026-01-01 22:27:51.819
fb355b2a-805f-4b04-ab37-e80c2bfdd144	Do Promise callbacks go on the call stack immediately?	No Γ¥î\n\nPromise callbacks:\n\n1. Execute after the current call stack finishes\n2. Are queued in the **Microtask Queue**\n3. Are pushed to the stack **before any macrotasks**\n\nPromises are async, but **not multithreaded**.	JavaScript	{promises,"call stack"}	easy	2026-01-01 22:28:26.267	2026-01-01 22:28:26.267
8a1d81e1-6fc5-46df-9dd0-c117c32b66db	What happens to the call stack when an error is thrown?	- The stack **unwinds**\n- Execution contexts are popped\n- Control moves up the stack\n- If unhandled ΓåÆ program crashes\n\nStack trace shows the **exact call chain**.	JavaScript	{"call stack"}	easy	2026-01-01 22:35:35.927	2026-01-01 22:35:35.927
6a8d2e90-2b4a-44d8-9fde-9827079a88a0	What is the output and why?	```js\nconsole.log("A");\n\nsetTimeout(() => console.log("B"), 0);\n\nPromise.resolve().then(() => console.log("C"));\n\nconsole.log("D");\n```\n\n\nA\nD\nC\nB\n\nExplanation:\n\n1. A, D ΓåÆ synchronous ΓåÆ call stack\n2. Promise ΓåÆ microtask queue\n3. setTimeout ΓåÆ task queue\n4. Microtasks always run before tasks	JavaScript	{promises}	easy	2026-01-01 22:29:05.802	2026-01-01 22:33:50.366
\.


--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.users (id, email, "passwordHash", "createdAt", "updatedAt") FROM stdin;
0fad466a-c673-42df-b29f-f79c17d04592	shkondachki@citt.bg	$2b$10$ftzdPaOBCLf0N4fMA80/xO4/atpnaNxSyR5JuJAOeki1cg8f0XHyi	2025-12-28 15:24:28.766	2025-12-28 15:24:28.766
\.


--
-- PostgreSQL database dump complete
--

\unrestrict KTTQNQdZ7TAGnYMTQBJ3dkljGT0M11ptmkK0ZByaYA60ovQO5aWfOuwZYW8aLLy

